---
title: 并查集
date: 2022-11-05 22:38:53
tags: 图论
---
## 板子
并查集是一种最为简洁而又优雅的数据结构。并查集是一种可以动态维护若干个不重叠的集合，支持合并与查询的数据结构。
并查集有两种基本操作：

+ 合并（Merge）：把两个集合合并为一个集合。
+ 查询（Find）：查询一个元素在哪个集合。


集合的表示方式采用代表元法：即在每一个集合中选取一个固定的元素作为集合的代表。并查集使用树形结构来存储集合，树上每一个节点是一个元素，树根是集合元素的代表。

如是还是慢，于是人们想出了优化：
+ 路径压缩（会损失信息，有些题不可用）：每次执行find时候将元素全部直接只向根节点
+ 按秩合并（有些题会对于合并时哪个作根给出限制，此时不可用）：类似于启发式和并的思想，将小结构和并到大结构上，当将集合大小作为秩时就是启发式合并（好写，但是将集合大小作为秩是可以卡的，但是基本没人会去卡，实在不行，随机合并，大抵是难卡的），将没有路径压缩时的深度作为秩，好像比较好（但是其实只写路径压缩是nlogn,一般不卡时限就差不多了）。


Tarjan Robert证明了同时使用路径压缩和按秩合并的并查集$\alpha(N)$的复杂度，在OI中几乎可以认为是常数
```cpp
int fa[MAXN];//父节点
int sz[MAXN];//集合大小作为秩
inline int build(int n){for(int i = 1;i<=n;i++)fa[i] = i,sz[i] = 1;}//开始时一个元素构成一个集合
inline int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}//路径压缩
inline void merge(int u,int v){//启发式合并
    if(sz[u]>sz[v])swap(u,v);
    fa[u] = v,sz[v]+=sz[u];
}
```
## 应用
并查集常常用于解决连通性问题，擅长动态维护许多有传递性的关系


